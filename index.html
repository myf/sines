<!DOCTYPE html>
<style>

html, body {
	height: 100%;
}

body {
	margin: 0;
	position: relative;
}

#canvasEl {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
}

</style>
<canvas id=canvasEl></canvas>
<script id="vShaderEl" type="x-shader">

attribute vec2 aVertexPosition;

void main() {
	gl_Position = vec4(aVertexPosition, 0.0, 1.0);
}

</script>
<script id="fShaderEl" type="x-shader">
precision mediump float;
uniform float PI;
uniform float time;

float square(float x) {
    return x * x;
}

void main(void) {
	vec2 c = gl_FragCoord.xy;
	float rgb = 0.5 + sin(time*0.02)/2.0
										//+ sin(2.0*PI*50.0*c.x+time*0.03)/2.0
										//+ sin(2.0*PI*80.0*c.y+time*0.02)/2.0
										//+ sin(2.0*PI*.005*sqrt(square(c.x)+square(c.y))+time*0.1)
										//+ sin(2.0*PI*.005*sqrt(square(c.x)+square(c.y))+time*0.1)
										//+ sin(2.0*PI*.005*sqrt(square(resolution.x-c.x)+square(c.y))+time*0.1)
										//+ sin(2.0*PI*.005*sqrt(square(resolution.x*2.0-c.x)+square(c.y))+time*0.1)
										//+ sin(2.0*PI*5.0*sqrt(
										//	square(c.x) +
										//	square(c.y)
										//)-time*0.1)
										//+ sin(2.0*PI*5.0*sqrt(
										//	square(1.0 - c.x) +
										//	square(c.y)
										//)+time*0.1)
										+ sin(2.0*PI*10.0*sqrt(
											square(c.x) +
											square(1.0 - c.y)
										)-time*0.01)
										+ sin(2.0*PI*10.0*sqrt(
											square(1.0 - c.x) +
											square(c.y)
										)-time*0.01)
										//+ sin(2.0*PI*20.0*sqrt(
										//	square(((cos(time / 70.0) + 1.0) / 2.0) - c.x) +
										//	square(((sin(time / 100.0) + 1.0) / 2.0) - c.y)
										//)+time*0.1)
										//+ sin(2.0*PI*20.0*sqrt(square(0.6 - c.x)+square(c.y))-time*0.1)
										//+ sin(2.0*PI*100.0*sqrt(square(resolution.x*2.0-x)+square(y))-time*0.1);
									;
	gl_FragColor = vec4(
			rgb * sin(time * 0.03),
			rgb * cos(time * 0.05),
			rgb * sin(time * 0.11),
		1.0);
}

</script>
<script>
'use strict';

const gl = canvasEl.getContext('webgl');

const squareVertices = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, squareVertices);
	
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
	1.0, 1.0, -1.0, 1.0, 1.0, -1.0,
	1.0, -1.0, -1.0, -1.0, -1.0, 1.0
]), gl.STATIC_DRAW);

const vShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vShader, vShaderEl.text);
gl.compileShader(vShader);

const fShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fShader, fShaderEl.text);
gl.compileShader(fShader);

const program = gl.createProgram();
gl.attachShader(program, vShader);
gl.attachShader(program, fShader);
gl.linkProgram(program);

gl.useProgram(program);

const timeLoc = gl.getUniformLocation(program, 'time');

const piLoc = gl.getUniformLocation(program, 'PI');
gl.uniform1f(piLoc, Math.PI);

const aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
gl.enableVertexAttribArray(aVertexPosition);
gl.vertexAttribPointer(aVertexPosition, 2, gl.FLOAT, false, 0, 0);

function draw(now) {
	gl.uniform1f(timeLoc, now);
	gl.drawArrays(gl.TRIANGLES, 0, 6);
	requestAnimationFrame(draw);
}

requestAnimationFrame(draw);

</script>
